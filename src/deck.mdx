import myTheme from './theme'
import Wrapper from './components/Wrapper'
import RegexCompare from './components/RegexCompare'
import StyledLink from './components/StyledLink'
import {CodeColorStyle} from './components/Styles'

export const theme = myTheme

# Regular Expressions

---

<Wrapper>

## Definition

A regular expression, regex or regexp (sometimes called a rational expression) is a sequence of characters that define a search pattern.

</Wrapper>

---

## Match types

---

<Wrapper>

## Literal character

- Any character matches to it's current value

- The exception characters to this rule are <CodeColorStyle>[\^$.|?*+()</CodeColorStyle> 

- Case sensitivity matters, unless there is a flag specified

<RegexCompare texts={["qwe"]} answerPattern={"qwe"}/>

</Wrapper>

---

<Wrapper>

## Non printable characters

- <CodeColorStyle>\t</CodeColorStyle> for tabs
- <CodeColorStyle>\r</CodeColorStyle> for carriage return
- <CodeColorStyle>\n</CodeColorStyle> for line feed (new line)
- Others:
  - <CodeColorStyle>\a&nbsp;&nbsp;\e&nbsp;&nbsp;\f&nbsp;&nbsp;\v</CodeColorStyle>

</Wrapper>

---

<Wrapper>

## Character classes/sets

- Any character inside the braces will match
  - <CodeColorStyle>[ae]</CodeColorStyle> gray grey
- To specify a range of characters, use hyphen character (<CodeColorStyle>-</CodeColorStyle>)
  - <CodeColorStyle>[0-9]</CodeColorStyle> will match any single digit between 0 and 9
- You can specify more than a single range inside the braces
  - <CodeColorStyle>[0-9a-fA-F]</CodeColorStyle>

</Wrapper>

---

<Wrapper>

<RegexCompare texts={["gray", "grey"]} pattern={""} answerPattern={"gr[ae]y"}/>
<br/>
<RegexCompare texts={["0x01f", "0x12a", "0xAef"]} pattern={"[0-9a-fA-F]+"} answerPattern={"0x[0-9a-fA-f]+"}/>

</Wrapper>

---

<Wrapper>

## Character classes/sets (2)

- <CodeColorStyle>^</CodeColorStyle> character inside the brackets negates the expression.

<RegexCompare texts={["acdefg"]} shouldNotMatchTexts={["abcdefg"]} pattern={""} answerPattern={"[^b]+"}/>

</Wrapper>

---


<Wrapper>

## Shorthand character classes

- <CodeColorStyle>\w</CodeColorStyle> will match any <i>word</i> character

  - Equal to <CodeColorStyle>[a-zA-Z0-9_]</CodeColorStyle>

- <CodeColorStyle>\d</CodeColorStyle> will match any <i>digit</i>

  - Equal to <CodeColorStyle>[0-9]</CodeColorStyle>

- <CodeColorStyle>\s</CodeColorStyle> will match any <i>whitespace</i> character

  - Including tabs and line breaks

</Wrapper>

---

<Wrapper>

<RegexCompare
  texts={["these", "are", "some", "words", "snake_case_variable1", "camelCaseVariable1"]}
  pattern={""}
  answerPattern={"\\w+"}
  />
<br/>
<RegexCompare texts={["some    spaced       words"]} pattern={""} answerPattern={"[\\w\\s]+"}/>

</Wrapper>

---

<Wrapper>

## Shorthand character classes (2)

- <CodeColorStyle>\W</CodeColorStyle> will match any <i> non word</i> character

  - Equal to <CodeColorStyle>[</CodeColorStyle><CodeColorStyle>^a-zA-Z0-9_]</CodeColorStyle>

- <CodeColorStyle>\D</CodeColorStyle> will match any <i> non digit</i>

  - Equal to <CodeColorStyle>[</CodeColorStyle><CodeColorStyle>^0-9]</CodeColorStyle>

- <CodeColorStyle>\S</CodeColorStyle> will match any <i>non whitespace</i> character


</Wrapper>

---

<Wrapper>

## Wildcard operator

- <CodeColorStyle>.</CodeColorStyle> will match any character, except line break characters

<RegexCompare texts={["abcd0*     -x="]} pattern={""} answerPattern={".+"}/>

</Wrapper>

---

<Wrapper>

## Anchors

- <CodeColorStyle>^</CodeColorStyle> will mark <i>beginning</i> of the search string
- <CodeColorStyle>$</CodeColorStyle> will mark <i>ending</i> of the search string
- <CodeColorStyle>\b</CodeColorStyle> will match at <i>word boundaries</i>

</Wrapper>

---

<Wrapper>

## Alternation

- Or operator for regular expressions
- Same symbol as in binary or operation in most programming languages (<CodeColorStyle>|</CodeColorStyle>)

<RegexCompare texts={["cat", "dog"]} answerPattern={"cat|dog"}/>

</Wrapper>

---

<Wrapper>

## Repetition

- For making the previous token optional (0 or 1 repeat), use <CodeColorStyle>?</CodeColorStyle>
- For making the previous token repeat 0 or more times, use <CodeColorStyle>*</CodeColorStyle>
- For making the previous token repeat 1 or more times, use <CodeColorStyle>+</CodeColorStyle>
- For custom repeat count, use <CodeColorStyle>{}</CodeColorStyle>
  - {2}
  - {2, 5}

<RegexCompare texts={["color", "colour"]} pattern={"colo"} answerPattern={"colou?r"}/>

</Wrapper>

---

<Wrapper>

<RegexCompare texts={["a", "bb", "ccc"]} shouldNotMatchTexts={["asdf", "zxcvb", "qwerty"]} answerPattern={"\\w{1,3}"}/>

</Wrapper>

---

<Wrapper>

## Greedy and Lazy Repetition

- Regular expressions are greedy by default
- To make a quantifier lazy, add <CodeColorStyle>?</CodeColorStyle> after quantifier

<RegexCompare texts={["abcde"]} shouldNotMatchTexts={["abcdeeee"]} answerPattern={"\\w*?e"} />
</Wrapper>

---

<Wrapper>

## Grouping and Capture Groups

- Adding <CodeColorStyle>()</CodeColorStyle> around multiple tokens group them together
  - This is called capture group
  - You can apply a quantifier to the group
  - Regex groups are indexed by 0, but the 0th group contains entire matched content
- If you need a group, but do not need to capture it, add <CodeColorStyle>?:</CodeColorStyle> as the first 2 characters inside the paranthesis

</Wrapper>

---

<Wrapper>

## Backreferences

- Within a regular expression it is possible to search & use a previously captured value in the same expression

- 

question idea -> Convert x = x + 1 y = y * 5 to x += 1 ...

</Wrapper>

---

<Wrapper>

## Named groups & Backreferences

- We can name capture groups and reference them by their name
- This is especially useful when you have many capture groups
- To name a group add <CodeColorStyle>?<groupName\></CodeColorStyle> at the beginning of the capture group.
  - (?<myGroup\>[abc]+)
- To backreference the group syntax is like <CodeColorStyle>\k<groupName\></CodeColorStyle>

</Wrapper>

---

<Wrapper>

## Lookaround groups (Lookahead & Lookbehind)


- There are 2 types of lookahead:
  - Positive lookahead: Match a token which continues with another token
    - u(?=c)
    duck dump
    Lookahead lookbehind
  - Negative lookahead: Match a token which does not continue with another token
    - a(?!d)
    Lookahead
- There are 2 types of lookbehind:
  - Positive lookbehind: Match a token which begins with another token
    - (?<=a)b
  - Negative lookbehind: Match a token which does not begin with another token
    - (?<!a)b
- While using lookahead and lookbehind content inside the lookahead/lookbehind will be discarded.
  - If you want to store the match for the lookahead/lookbehind, you can use a capture group


</Wrapper>

---
add regex flags

---

### Useful Sites

- <StyledLink link="https://www.regular-expressions.info"/>
- <StyledLink link="https://regex101.com"/>
- <StyledLink link="https://regexr.com"/>
- <StyledLink link="https://www.debuggex.com"/>